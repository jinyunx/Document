注：
重度参考了：https://www.zhihu.com/question/30272728/answer/72476703（讲的非常好，逻辑清晰）
轻度参考了：https://www.cnblogs.com/fjdingsd/p/5273008.html（概念也比较清晰，只不过没有对比着这两个特性讲）
 
概念
原子性：一个事务内的操作，要么同时成功，要么同时失败
一致性：一个事务必须使数据库从一个一致性状态变换到另一个一致性状态
 
对于一致性，知乎链接中内容如下：
```
首先回顾一下一致性的定义。所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。
```
从这段话的理解来看，所谓一致性，即，从实际的业务逻辑上来说，最终结果是对的、是跟程序员的所期望的结果完全符合的
 
重点
一致性是基础，也是最终目的，其他三个特性（原子性、隔离性和持久性）都是为了保证一致性的
在比较简单的场景（没有高并发）下，可能会发生一些数据库崩溃等情况，这个时候，依赖于对日志的 REDO/UNDO 操作就可以保证一致性
而在比较复杂的场景（有高并发）下，可能会有很多事务并行的执行，这个时候，就很可能导致最终的结果无法保证一致性，比如（内容来自知乎链接）：
```
但是，原子性并不能完全保证一致性。<b>在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。</b>例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。
```
即，这个时候，原子性不能保证一致性。因为从单个事务的角度看，不管是事务 1 还是事务 2，它们都保证的原子性（单个事务内的所有操作全部成功了），但最终，它们并没有保证数据库的一致性（因为从逻辑上说，账户 A 应该增加了 200 元，而不是 100 元）
所以，为了保证并发情况下的一致性，又引入了隔离性的概念
 
隔离性：即事务之间感知不到彼此的存在，就好像只存在本身一个事务一样
而对于怎样实现隔离性，又涉及到了乐观锁和悲观锁的概念（这两个概念还不大懂）
 
小小引申：
不考虑隔离性的时候，可能导致脏读、幻读和不可重复读的问题（这些问题，其实就是导致无法保证一致性的几种情况）
而隔离级别的概念，就是为了解决上述三个问题
