### 数组
1.默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0  
2.在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算  
3.数组可以指定一个索引和对应值列表的方式初始化，例如：
```go
r := [...]int{99: -1}
```
定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化  
4.元素个数是数组类型的一部分，所以[3]int和[4]int是不同的两个类型，两个类型的变量不可相互赋值  
5.数组传递给函数时，整体复制进去，因此大数组传递将会效率低下  
### slice
1.slice和string有类似的地方，都是一个结构体，结构体含有指针指向实际的内容，所以传递给函数时并没发生深复制，效率较高。不同的是slice有容量的概念，因为slice往往是指向数组的一个切片，容量就是底层数组的实际最大长度。  
2.一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并```不一定就是数组的第一个元素```。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。  
3.字符串的切片操作和[]byte字节类型切片的切片操作是类似的。它们都写作x[m:n]，并且都是返回一个原始字节系列的子序列，底层都是共享之前的底层数组，因此切片操作对应常量时间复杂度  
4.例子
```go
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
```
如果传递数组，那么效率很低，这里先把数组转换成slice，slice的底层数据就是这个原始数组，所以reverse会体现在这个原始数组上。  
5.make
```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```
6.append函数使用时，当slice底层数组没有足够空间时，会重新开辟一个足够大的空间（一般是原空间的两倍），然后把老的数据copy过去，再添加新的数据。由于append是值传递，所以slice header的修改不会体现在原slice上，所以一般这样使用：a=append(a,b)