1.函数传递为完全复制：  
```
整形/浮点数/复数/布尔
数组
结构体
```
 函数传递复制header的类型，即浅复制：
 ```
 字符串
 slice
 map
 ``` 
2.函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用  
  
3.err的处理应该这样写：  
```go
if err := handle(); err != nil {
    log.Fatal(err)
}
```
4.多个goroutine处理同一个资源时应使用mutex进行保护：  
```go
var mutex sync.Mutex
mutex.Lock()
// protection
mutex.Unlock()
```
5.Go语言的```switch case```并不需要显式地在每一个```case```后写```break```，语言默认执行完```case```后的逻辑语句会自动退出。当然了，如果你想要相邻的几个```case```都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过```fallthrough```语句在一般的程序中很少用到。  
   
6.```switch```不带操作对象时默认用```true```值代替，然后将每个```case```的表达式和true值进行比较  
  
7.指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作  
  
8.Go语言没有```double```，有```float32 float64```，没有```char short```，有```byte int int8 int16 int32 int64```  
  
9.不像C语言局部变量不初始化则为随机值，Go语言如果初始化表达式被省略，那么将用```零值```初始化该变量。数值类型变量对应的零值是0，布尔类型变量对应的零值是```false```，字符串类型对应的零值是空字符串，接口或引用类型（包括```slice、map、chan```和函数）变量对应的零值是```nil```。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。Go语言中不存在未初始化的变量。  
  
10.简短变量声明（```名字 := 表达式```）只能用于函数内部。  
10.1.如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。  
10.2.简短变量声明语句中必须至少要声明一个新的变量。  
10.3.简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。  
  
11.将一个浮点数转为整数将丢弃小数部分，将一个字符串转为```[]byte```类型的```slice```将拷贝一个字符串数据的```副本```。在任何情况下，运行时不会发生转换失败的错误，错误只会发生在编译阶段  
  
12.import 目录/包名相关  
12.1.import导入的是```路径```。而非```包名``` 
12.2.最好```包名```和```目录名```保持一致，但是并不强制  
12.3.代码中引用包成员使用```包名```，而非```目录名```  
12.4.同一目录的所有源文件必需使用```相同```包名称（不然导入用一个目录会歧义）  
12.5.```文件名```随意起  
12.6.目录和包名不一致时，一般这样import：
```go
import packagename path/to/package
```
  
13.初始化顺序相关  
13.1.单文件内，根据```依赖关系```进行顺序初始化，被依赖的变量先初始化  
13.2.单文件内，变量初始化先于init函数  
13.3.单包内，先初始化包内所有分布在多个文件中的```全局变量```，再初始化包内所有文件的```init函数```  
13.4.单包内，多文件的变量和init初始化顺序依赖```文件名字母顺序```  
13.5.多个包被引用，初始化依赖```import顺序```，多重import时，按照深度优先顺序  
13.6.循环import会编译失败    

14.隐式作用域(和c++一样)
```go
if x := f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here
```
  
15.坑，init域中使用:=，则会新定义变量，忽略外部作用域的变量
```go
var cwd string

func init() {
    cwd, err := os.Getwd() // NOTE: wrong!
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
    log.Printf("Working directory = %s", cwd)
}
```
16.```int```在64位平台占64bits，在32位平台占32bits  
17.布尔值并不会隐式转换为数字值0或1，反之亦然  
18.如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的  
19.看如下例子：
```go
const {
    zero = 1 << iota
    one
    two
    three
}
```
由18可知，不写值的将会复制上一个表达式即：
```go
const {
    zero = 1 << iota
    one = 1 << iota
    two = 1 << iota
    three = 1 << iota
}
```
但是iota每次使用都会加1，所以实际为：
```go
const {
    zero = 1 << 0
    one = 1 << 1
    two = 1 << 2
    three = 1 << 3
}
```
20.数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长  
21.在向map存数据前必须先创建map  
22.map传递给函数，也是复制map header
```go

func changeMap(m map[string]int) {
    // m["oqp"] = 678 // effect the outside map
	m = map[string]int{ // change the function tmp varible m map header, has nothing to effect the outside map
		"abc": 123,
	}
}

func main() {
	b := map[string]int{
		"opq": 345,
	}
	log.Println(b) // map[opq:345]
	changeMap(b)
	log.Println(b) // map[opq:345]
}
```
23.结构体为完全复制类型
```go

type user struct {
	name string
}

func changeStruct(m user) {
	m.name = "456"
	m = user{
		name: "123",
	}
}

func main() {
	b := user{
		name: "345",
	}
	log.Println(b)   // {345}
	changeStruct(b)
	log.Println(b)   // {345}
}
```
