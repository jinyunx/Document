1.函数传递为引用：  
map  
  
2.函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用  
  
3.err的处理应该这样写：  
```go
if err := handle(); err != nil {
    log.Fatal(err)
}
```
4.多个goroutine处理同一个资源时应使用mutex进行保护：  
```go
var mutex sync.Mutex
mutex.Lock()
// protection
mutex.Unlock()
```
5.Go语言的```switch case```并不需要显式地在每一个```case```后写```break```，语言默认执行完```case```后的逻辑语句会自动退出。当然了，如果你想要相邻的几个```case```都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过```fallthrough```语句在一般的程序中很少用到。  
   
6.```switch```不带操作对象时默认用```true```值代替，然后将每个```case```的表达式和true值进行比较  
  
7.指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作  
  
8.Go语言没有```double```，有```float32 float64```，没有```char short```，有```byte int int8 int16 int32 int64```  
  
9.不像C语言局部变量不初始化则为随机值，Go语言如果初始化表达式被省略，那么将用```零值```初始化该变量。数值类型变量对应的零值是0，布尔类型变量对应的零值是```false```，字符串类型对应的零值是空字符串，接口或引用类型（包括```slice、map、chan```和函数）变量对应的零值是```nil```。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。Go语言中不存在未初始化的变量。  
  
10.简短变量声明（```名字 := 表达式```）只能用于函数内部。  
10.1.如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。  
10.2.简短变量声明语句中必须至少要声明一个新的变量。  
10.3.简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。